1. SELECT fullname FROM clients WHERE bdate = TRUNC(sysdate, 'dd');

2. SELECT COUNT(*) FROM clients WHERE bdate IS NULL;

3. SELECT SUM(CASE WHEN bdate IS NULL THEN 1 ELSE 0) FROM clients

4. SELECT bdate FROM (SELECT ROW_NUMBER(PARTITION BY PCODE ORDER BY BDATE DESC) AS rn FROM clients) WHERE rn = 2;
--Знаю как использовать с агрегирующими функциями, понимаю, что Вы хотите посмотреть как я ими владею, но тут не было условий, что без них нельзя.

5. SELECT bdate FROM (SELECT ROW_NUMBER(PARTITION BY PCODE ORDER BY BDATE DESC) AS rn FROM clients) WHERE rn = 2;

6. SELECT clnt.* FROM clients clnt WHERE NOT EXISTS(SELECT 1 FROM treat trt WHERE trt.pcode = clnt.pcode) 

7. SELECT clnt.* FROM clients clnt WHERE EXISTS(SELECT 1 FROM treat trt WHERE trt.pcode = clnt.pcode) 

8. SELECT treatcode, pcode, dcode, treatdate, amountcl, amountjp, histid FROM (SELECT *, RANK(PARTITION BY TREATCODE ORDER BY AMOUNTCL) AS rn FROM treat) WHERE rn = 1;

10. SELECT full_name, bdate, MAX(cnt) FROM (SELECT full_name, bdate, ROW_NUMBER(PARTITION BY fullname, bdate) AS cnt from clients) WHERE cnt > 1 GROUP BY full_name, bdate;



11. SELECT DOC.DNAME, SUM(TRT.AMOUNTCTL) AS СТОИМОСТЬ FROM DOCTOR doc JOIN TREAT TRT ON trt.dcode = doc.dcode group by doc.dname HAVING SUM(TRT.AMOUNTCTL > 10000);


12. SELECT * FROM (SELECT *, ROW_NUMBER(PARTITION BY HISTID ORDER BY fdate desc) AS rn FROM clhistnum) WHERE rn = 1;

13. SELECT doc.name, ABS((SELECT AVG(AMOUNTCL) 
						  FROM TREAT WHERE EXTRACT(YEAR FROM TREAT_DATE) = 2019 
						  AND dcode = trt.dcode) - 
						(SELECT AVG(AMOUNTCL) FROM TREAT 
						WHERE EXTRACT(YEAR FROM TREAT_DATE) = 2018 
						AND dcode = trt.dcode)) AS ABS_AMOUNTCL_DIFF_2019_2018  
	FROM TREAT trt JOIN doctor doc ON doc.dcode = trt.dcode; 
-- Для лучшей читаемости можно было решить через CTE, но я решил для тестового сделать так.

14. SELECT clnt.fullname, jpgrmnt.agrid from clients clnt join clhistnum clh on clh.pcode = clnt.pcode join jpersons












